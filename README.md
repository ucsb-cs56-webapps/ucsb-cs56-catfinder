# ucsb-cs56-catfinder
Check out the running product here: https://ucsb-cs56-wilson-08-18.herokuapp.com/

The simplest possible SparkJava web app (Hello World)

* [javadocs](https://ucsb-cs56-pconrad.github.io/sparkjava-01/apidocs/index.html)
* [web page generated by Maven (NOT THE WEB APP)](https://ucsb-cs56-pconrad.github.io/sparkjava-01/index.html).  This is simply documentation automatically generated by Maven, not the actual running web app.

# Basics of JSON

1. What does it stand for?  
JSON - JavaScript Object Notation.

2. What is it?  
A data interchange format that gathers and shares data among applications and interfaces.

3. Why JSON?  
It is a text-based, language-independent data exchange format that is easy for human to read.

4. What does it look like?  
JSON provides data to calling functions in key-value pairs, where key is the name of the variable and value is its corresponding value. 

5. How are the key value pairs stored?  
There are two structured types in JSON, objects and arrays. An object is unordered and has zero or more key-value pairs, whereas an array is ordered and has zero or more values. The values can be strings, numbers, booleans, null, or even these two structured types.

# Using a RestAPI to retrieve JSON and load into our model

The API being used here is from PetFinder. It will be used to retrieve a JSON containing a list of cats. 
Documentation for this API can be found here: https://www.petfinder.com/developers/api-docs.

For GET calls, the format of the url is like this:
```
http://api.petfinder.com/my.method?key=12345&arg1=foo
```
The method used here will be pet.find. The required parameters are "key" and "location". We want our response to be in JSON,
so we will also pass that argument and our query will look like the following:

```
http://api.petfinder.com/pet.find?key=" + key + "&animal=cat&location=93117&format=json
```

Here is the JSON tree returned from the API. I removed a lot of irrelevant fields for simplicity.
However, the paths to the data we want are the same in my edited version and the actual. I would recommend using a tool such as Insomnia to see what our query will return.

```
{
	"petfinder": {
		"pets": {
			"pet": [
				{
					"media": {
						"photos": {
							"photo": [
								{
									"@size": "pnt",
									"$t": "http://photos.petfinder.com/photos/pets/35958838/1/?bust=1493239347&width=60&-pnt.jpg",
									"@id": "1"
								}
							]
						}
					},
					
					"name": {
						"$t": "Elsie"
					},
					"sex": {
						"$t": "F"
					},
					"description": {
						"$t": "Elsie came to us in desperate need of a home.  A senior cat at 14 years old, she is in good health considering the miles she's traveled.  Elsie is very sweet and petite.  We're hoping there will be an angel out there looking for an older companion.  Elsie weighs 7lbs.and is microchipped."
					}
				},
				{
					"media": {
						"photos": {
							"photo": [
								{
									"@size": "pnt",
									"$t": "http://photos.petfinder.com/photos/pets/40943615/1/?bust=1518559770&width=60&-pnt.jpg",
									"@id": "1"
								}
							]
						}
					},
					"name": {
						"$t": "Gypsy"
					},
					"sex": {
						"$t": "F"
					},
					"description": {
						"$t": "Our adoptable cats are spayed/neutered, vaccinated, and microchipped.\n"
					}
				}
			]
		}
	}
}
```

Our model representing each cat will be defined in PetModel.java. There will be default values in case some data are missing from the API.

```
public class PetModel {
    public String name = "";
    public String gender = "";
    public String description = "";
    public String img = "https://upload.wikimedia.org/wikipedia/commons/thumb/2/2b/Black_Cat_Vector.svg/2000px-Black_Cat_Vector.svg.png";
}
```

To start, add this JSON dependency. It will allow us to create JSONObjects.
```
      <!-- JSON -->
      <dependency>
          <groupId>org.json</groupId>
          <artifactId>json</artifactId>
          <version>20150729</version>
      </dependency>
```
In our main, we can use an Arraylist to store all of our created PetModels.
```
        ArrayList<PetModel> pets = new ArrayList<>();

```

So let's really start! In this short guide, everything will be done within here:

```
get("/sample", (req, res) -> { we will do everything in here }

```
For details on config var values, refer to:
https://devcenter.heroku.com/articles/config-vars.
Store your key in an .env file and be sure to ignore that from git.
If you don't want to deal with that yet, just replace 'key' with your API key. (bad practice makes perfect)
```
            String key = System.getenv("PETFINDER_KEY");
            String urlString = "http://api.petfinder.com/pet.find?key=" + key + "&animal=cat&location=93117&format=json";
```
Create a URL with the url formed and open a connection. We will be 'getting', so set the request method like so.
Get the response code. If it is not 200, then that means there is an issue.

```
            URL url = new URL(urlString);
            HttpURLConnection connection = (HttpURLConnection) url.openConnection();

            connection.setRequestMethod("GET");
            connection.connect();

            int responsecode = connection.getResponseCode();
            if (responsecode != 200) { System.out.println("oh no");}
```
Now that we are connected, we want to read in the data provided by the API. Here we will do this with a Scanner.
Build a String with the data. We can use this string to form our JSONObject. 
```
            Scanner sc = new Scanner(url.openStream());
            String inline = "";
            while (sc.hasNext()) {
                inline += sc.nextLine();
            }
            sc.close();
```

We will then store every pet in the JSON file as a PetModel by following the steps below:

1. Create a new JSONObject from the string read by the scanner.  
2. For each JSONObject, "<JSONObject>".get("<field>") can be called to retrieve the corresponding value. In our case, make each pet in the array of pets into a JSONObject and cast each field in pet to a JSONObject. Notice that some fields in the JSON tree have brackets instead of curly brackets, which means they need to be casted to a JSONArray instead of a JSONObject.  
3. After getting to the innermost layer, we call .toString() on the JSON Object to return the string of its values.

Watch out for fields that can be empty. Trying to create an object from it will cause an error, which can be avoided by checking if the length of the object is 0.

The idea here is to iterate through the JSON array of pets. Parse the data from each pet, store it in a 
PetModel, and then add it to an ArrayList of PetModels.
```
            JSONObject json = new JSONObject(inline);
            json = (JSONObject) json.get("petfinder");
            json = (JSONObject) json.get("pets");

            JSONArray json_pets = (JSONArray) json.get("pet");
            for (int i = 0; i < json_pets.length(); i++) {
                PetModel pet = new PetModel();
                JSONObject json_pet = (JSONObject) json_pets.get(i);
                JSONObject json_pet_name = (JSONObject) json_pet.get("name");
                JSONObject json_pet_gender = (JSONObject) json_pet.get("sex");
                JSONObject json_pet_description = (JSONObject) json_pet.get("description");
                JSONObject json_pet_img = (JSONObject) json_pet.get("media");

                if (json_pet_img.length() != 0) {
                    json_pet_img = (JSONObject) json_pet_img.get("photos");
                    JSONArray json_pet_img_arr = (JSONArray) json_pet_img.get("photo");

                    if (json_pet_img_arr.length() != 0) {
                        for (int k = 0; k < json_pet_img_arr.length(); k++) {
                            json_pet_img = (JSONObject) json_pet_img_arr.get(0);
                        }
                    }

                    pet.img = json_pet_img.get("$t").toString();
                }

                if (json_pet_name.length() != 0) {
                    pet.name = json_pet_name.get("$t").toString();
                }
                if (json_pet_description.length() != 0) {
                    pet.description = json_pet_description.get("$t").toString();
                }
                if (json_pet_gender.length() != 0) {
                    pet.gender = json_pet_gender.get("$t").toString();
                }

                pets.add(pet);
            }
```

We can iterate through our list of PetModels to check if things are working.
```
            for ( PetModel cat:pets) {
                System.out.println("name: " + cat.name + " gender: " + cat.gender);
            }

            return "";
```


# Using Freemarker as a template engine

With a template engine, a template can be thought of as a 'view' in the Model-View-Controller design pattern. It is essentially a layout with parameters.
Here is how to start using FreeMarker.

In your pom.xml, include Freemarker as a dependency:

```
        <dependency>
          <groupId>org.freemarker</groupId>
          <artifactId>freemarker</artifactId>
          <version>2.3.28</version>
        </dependency>
       
```

Create a layout file in your jar. Freemarker uses .ftl files. It will be like html. Values can be inserted with ${id}. For example:

```
<html>
<head>
    <title>${title_value}/title>
</head>
<body></body>
</html>
```

Now, set up a Configuration instance. In this example, a layouts folder is adjacent to the class file. 
The templates will be loaded from the layouts folder under resources. A template named "home.ftl" is used.

```
    Configuration cfg = new Configuration(Configuration.VERSION_2_3_26);
    cfg.setClassForTemplateLoading(CatFinder.class, "/layouts/");
    cfg.setDefaultEncoding("UTF-8");
```

To insert values into the template:

```
get("/", (Request req, Response res) -> {
            StringWriter writer = new StringWriter();
            Map attributes = new HashMap();
            attributes.put("title_value", "This is the home page");
            try {
                Template homeTemplate = cfg.getTemplate("home.ftl");
                homeTemplate.process(attributes, writer);
            } catch (Exception e) {
                System.out.println(e);
                System.out.println("home.ftl not found!");
                Spark.halt(500);
            }
            return writer;
        });
```

Using lists is a little trickier. In your .ftl file, add something like this:

```
<#list cats as cat>
    <div>
         <img src=${cat.img} width="300" height="200">
         <h3>${cat.name}</h3>
         <div">${cat.description}</div>
    </div>
</#list>
```

Note that the PetModel should resemble this:
```
public class PetModel {
    public String name = "";
    public String description = "";
    public String img = "https://upload.wikimedia.org/wikipedia/commons/thumb/2/2b/Black_Cat_Vector.svg/2000px-Black_Cat_Vector.svg.png";

    public String getName(){
        return name;
    }
    public String getDescription(){
        return description;
    }

    public String getImg(){
        return img;
    }
}
```

Each member should have a getter. The variable name should correlate to the label in your ftl.
In the attributes, the 'cats' within your template file should be mapped to an ArrayList of PetModels.
In the code below, cats is an ArrayList of PetModels. Processing the template will do all the mapping
of each PetModel member variable to its place in the template.

```
get("/results", (req, res) -> {

            StringWriter writer = new StringWriter();
            try {
                Map<String, Object> attributes = new HashMap<>();

                attributes.put("cats", cats);
                Template resultsTemplate = cfg.getTemplate("results.ftl");
                resultsTemplate.process(attributes, writer);
            } catch (Exception e) {
                System.out.println(e);
                System.out.println("results.ftl not found!");
                Spark.halt(500);
            }
            return writer;

        });
```



# To use

| To do this | Do this |
| -----------|-----------|
| run the program | Type `mvn exec:java`.  Visit the web page it indicates in the message |
| check that edits to the pom.xml file are valid | Type `mvn validate` |
| clean up so you can recompile everything  | Type `mvn clean` |
| edit the source code for the app | edit files in `src/main/java`.<br>Under that the directories for the package are `edu/ucsb/cs56/pconrad`  |
| edit the source code for the app | edit files in `src/test/java`.<br>Under that the directories for the package are `edu/ucsb/cs56/pconrad`  |
| compile    | Type `mvn compile` |
| run junit tests | Type `mvn test` |
| build the website, including javadoc | Type `mvn site-deploy` then look in either `target/site/apidocs/index.html`  |
| copy the website to `/docs` for publishing via github-pages | Type `mvn site-deploy` then look for javadoc in `docs/apidocs/index.html` |	
| make a jar file | Type `mvn package` and look in `target/*.jar` |

| run the main in the jar file | Type `java -jar target/sparkjava-demo-01-1.0-jar-with-dependencies.jar ` |
| change which main gets run by the jar | Edit the `<mainClass>` element in `pom.xml` |
